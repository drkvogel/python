
[Extending Our Functional Test Using the unittest Module ](https://www.obeythetestinggoat.com/book/chapter_02_unittest.html)

Tests that use Selenium let us drive a real web browser, so they really let us see how the application functions from the user’s point of view. That’s why they’re called functional tests.

Functional Test == Acceptance Test == End-to-End Test. Another term is black box test.

```diff
-assert 'Django' in browser.title
+assert 'To-Do' in browser.title
```
```
$ python functional_tests.py
```
```py
Traceback (most recent call last):
  File "functional_tests.py", line 10, in <module>
    assert 'To-Do' in browser.title
AssertionError
```

That’s what we call an expected fail, which is actually good news—not quite as good as a test that passes, but at least it’s failing for the right reason; we can have some confidence we’ve written the test correctly.

```diff
-assert 'To-Do' in browser.title
+assert 'To-Do' in browser.title, "Browser title was " + browser.title
```
```py
AssertionError: Browser title was Welcome to Django
```

And we could also use a try/finally to clean up the old Firefox window. But these sorts of problems are quite common in testing, and there are some ready-made solutions for us in the standard library’s unittest module. Let’s use that!

